* Automatic package installation
  This function makes it so that any package called with
  =packages-require= will be downloaded and installed.
  e.g: =(packages-require 'magit)=

#+begin_src emacs-lisp
  (require 'package)
  
  ;; add extra sources to the package archives
  (setq package-archives
        '(("melpa" . "http://melpa.milkbox.net/packages/")
          ("org". "http://orgmode.org/elpa/")
          ("marmalade" . "http://marmalade-repo.org/packages/")))
          
  
  ;; activate all the packages
  (package-initialize)
  
  ; fetch the list of packages available 
  (unless package-archive-contents
    (package-refresh-contents))
  
  ;; function to install a given list of packages.
  (defun packages-require (&rest package-list)
    (dolist (package package-list)
      (unless (package-installed-p package)
        (package-install package)))
    (package-initialize)
    (delete-other-windows))
  
  
#+end_src

* Appearance
  These lines of code disable most of the gui elements used in emacs
  so you can get so much more of that sweet, sweet text on your screen.
#+begin_src emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (setq inhibit-splash-screen t)
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
#+end_src
  
** Theme
   The theme that I use, nice for 
#+begin_src emacs-lisp
  (packages-require 'grandshell-theme)
  (load-theme 'grandshell t)
#+end_src
   Note that there is a small bug when using xterm-256color, where black is not really black.
   Hopefully this fixes it.
#+begin_src emacs-lisp
  (if window-system nil
   (set-face-background 'default "color-16"))
#+end_src   
* Extensions
** Magit
   This mode allows for interaction with git from within emacs.
   #+BEGIN_SRC emacs-lisp
   (packages-require 'magit)
   #+END_SRC

** smex
   This allows for autocomplete in the minibuffer when using =M-x= as
   well as fuzzy matching.
   #+BEGIN_SRC emacs-lisp
     (packages-require 'smex)
     
     ;;; Smex
     (autoload 'smex "smex"
       "Smex is a M-x enhancement for Emacs, it provides a convenient interface to
     your recently and most frequently used commands.")
     ;;; This adds a hyphen on space, instead of blocking.
     (defadvice smex (around space-inserts-hyphen activate compile)
       (let ((ido-cannot-complete-command 
              `(lambda ()
                 (interactive)
                 (if (string= " " (this-command-keys))
                     (insert ?-)
                   (funcall ,ido-cannot-complete-command)))))
         ad-do-it))
     
     ;;; This adds abbreviation to commands, so that magit-status for
     ;;; example might become mags
     ;;; Filters ido-matches setting acronynm matches in front of the results
     (defadvice ido-set-matches-1 (after ido-acronym-matches activate)
       (if (> (length ido-text) 1)
           (let ((regex (concat "^" (mapconcat 'char-to-string ido-text "[^-]*-")))
                 (acronym-matches (list))
                 (remove-regexes '("-menu-")))
             ;; Creating the list of the results to be set as first
             (dolist (item items)
               (if (string-match (concat regex "[^-]*$") item) ;; strict match
                   (add-to-list 'acronym-matches item)
                 (if (string-match regex item) ;; appending relaxed match
                     (add-to-list 'acronym-matches item t))))
     
             ;; Filtering ad-return-value
             (dolist (to_remove remove-regexes)
               (setq ad-return-value
                     (delete-if (lambda (item)
                                  (string-match to_remove item))
                                ad-return-value)))
     
             ;; Creating resulting list
             (setq ad-return-value
                   (append acronym-matches
                           ad-return-value))
     
             (delete-dups ad-return-value)
             (reverse ad-return-value))))
     
     (global-set-key (kbd "M-x") 'smex)
   #+END_SRC

** ido
   #+BEGIN_SRC emacs-lisp
     (packages-require 'ido-ubiquitous)
     (ido-ubiquitous-mode 1)
     
     (require 'ido)
     (ido-mode t)
     (setq ido-enable-prefix nil
           ido-enable-flex-matching t
           ido-case-fold nil
           ido-auto-merge-work-directories-length -1
           ido-create-new-buffer 'always
           ido-use-filename-at-point nil
           ido-max-prospects 10
           ido-case-fold t)
     
     (defun sd/ido-define-keys () ;; C-n/p is more intuitive in vertical layout
       (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
       (define-key ido-completion-map (kbd "<down>") 'ido-next-match)
       (define-key ido-completion-map (kbd "C-p") 'ido-prev-match)
       (define-key ido-completion-map (kbd "<up>") 'ido-prev-match))
     
     (add-hook
      'ido-setup-hook
      (lambda ()
        ;; Go straight home
        (define-key ido-file-completion-map
          (kbd "~")
          (lambda ()
            (interactive)
            (cond
             ((looking-back "~/") (insert "projects/"))
             ((looking-back "/") (insert "~/"))
             (:else (call-interactively 'self-insert-command)))))
     
        ;; Use C-w to go back up a dir to better match normal usage of C-w
        ;; - insert current file name with C-x C-w instead.
        (define-key ido-file-completion-map (kbd "C-w") 'ido-delete-backward-updir)
        (define-key ido-file-completion-map (kbd "C-x C-w") 'ido-copy-current-file-name)))
     
     ;; Always rescan buffer for imenu
     (set-default 'imenu-auto-rescan t)
     
     (add-to-list 'ido-ignore-directories "target")
     (add-to-list 'ido-ignore-directories "node_modules")
     
     ;; Fix ido-ubiquitous for newer packages
     (defmacro ido-ubiquitous-use-new-completing-read (cmd package)
       `(eval-after-load ,package
          '(defadvice ,cmd (around ido-ubiquitous-new activate)
             (let ((ido-ubiquitous-enable-compatibility nil))
               ad-do-it))))
     
     ;;; save this bit for later.
     ;;(ido-ubiquitous-use-new-completing-read webjump 'webjump)
     ;;(ido-ubiquitous-use-new-completing-read yas/expand 'yasnippet)
     ;;(ido-ubiquitous-use-new-completing-read yas/visit-snippet-file 'yasnippet)
   #+END_SRC
** Yasnippet
   Allows for expansion of abbreviations of code.

   For example expand =sysout= to =System.out.println= or something.
   #+BEGIN_SRC emacs-lisp
     (packages-require 'yasnippet)
     (require 'yasnippet)
     (yas-global-mode 1)
     
     ;; use built-in snippets as well as custom snippets (when I make them)
     (setq yas-snippet-dirs (append yas-snippet-dirs
                                    '("~/.emacs.d/snippets")))
   #+END_SRC
** auto-complete
   #+BEGIN_SRC emacs-lisp
     ;; auto complete stuff
     (require 'auto-complete)
     (add-to-list 'ac-dictionary-directories "~/.emacs.d/ac-dict")
     (require 'auto-complete-config)
     (ac-config-default)
     (global-auto-complete-mode t)
     (defun auto-complete-mode-maybe ()
       "No maybe for you. Only AC!"
       (unless (minibufferp (current-buffer))
         (auto-complete-mode 1)))
   #+END_SRC
** Parenthesis matching
   This needs to be fleshed out later when I have more spare time, but
   I guess that this will do for now. 

   #+BEGIN_SRC emacs-lisp
   (add-hook 'global-mode-hook 'electric-pair-mode)
   #+END_SRC

** Line char limit
   Setup a char limit of 100 chars for any text input. This is mostly
   for input in a thin terminal (like my phone)
   #+BEGIN_SRC emacs-lisp
     (setq-default auto-fill-function 'do-auto-fill)
     (set-fill-column 100)
   #+END_SRC

** Automatic save 
   Don't rely on emacs idle auto-save. 
   Tell it to save every 300 characters.
   #+BEGIN_SRC emacs-lisp
   (setq auto-save-interval 300) 
   #+END_SRC
** Org mode
   This section handles interaction between emacs and the various
   extensions that org mode handles.
*** Babel languages
    Extend the org language by allowing code to be executed as the org
    file is compiled.

    #+BEGIN_SRC emacs-lisp
      ;; active Org-babel languages
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((latex . t)
         (plantuml . t)))
      
      ;; fontify code in code blocks
      (setq org-src-fontify-natively t)
    #+END_SRC
*** Plantuml
    Plantuml is a pretty cool uml drawing tool that interacts with
    emacs well due to =plantuml-mode=
    #+BEGIN_SRC emacs-lisp
    (packages-require 'plantuml-mode)
    #+END_SRC

    Note that it requires the path to the jar file to be set in order
    to actually compile anything at all.
    #+BEGIN_SRC emacs-lisp
    (setq org-plantuml-jar-path
      (expand-file-name "/usr/share/plantuml/plantuml.jar"))
    #+END_SRC

** Indenting whole buffer
   #+BEGIN_SRC emacs-lisp
     ;; does what it says on the tin for any language.
     (defun iwb ()
       "indent whole buffer"
       (interactive)
       (delete-trailing-whitespace)
       (indent-region (point-min) (point-max) nil)
       (untabify (point-min) (point-max)))
     
     ;; set it to some handy key binding.
     (global-set-key (kbd "<f3>") 'iwb)
     
   #+END_SRC
** Custom yank function
   This yank function accepts a prefix arg, to say how many times to
   actually paste the stuff from the clipboard. Handy.
   #+BEGIN_SRC emacs-lisp
     (defun yank-repeat (arg)
       "With numerical ARG, repeat last yank ARG times. "
       (interactive "p*")
       (dotimes (i arg)
         (insert (car kill-ring))))
     (global-unset-key (kbd "C-y"))
     (define-key global-map (kbd "C-y") 'yank-repeat)
   #+END_SRC
